-- Cost Sharing API Database Schema
-- SQLite3 Schema for Flask Application (Simplified)
-- 
-- This schema implements the data model for the Cost Sharing API.
-- Simplified for small-scale class project (handful of users/groups, few hundred expenses).
-- 
-- All monetary amounts are stored as NUMERIC(10,2) for precision.
-- Expense dates are stored as DATE (YYYY-MM-DD format).
-- IDs are sequential integers, auto-generated by the database.

-- Enable foreign key constraints (required for SQLite)
PRAGMA foreign_keys = ON;

-- ============================================================================
-- USERS TABLE
-- ============================================================================
-- Stores user accounts. Users can be created via OAuth or as placeholders
-- when added to a group before they've logged in.

CREATE TABLE users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    is_placeholder INTEGER NOT NULL DEFAULT 0,  -- 0 = false, 1 = true
    -- OAuth provider ID (for Google OAuth user identification)
    oauth_provider_id TEXT
);

-- ============================================================================
-- GROUPS TABLE
-- ============================================================================
-- Stores cost-sharing groups. Each group has a creator and multiple members.

CREATE TABLE groups (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    created_by_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
    CHECK (length(name) >= 1),
    CHECK (description IS NULL OR length(description) <= 500)
);

-- ============================================================================
-- GROUP MEMBERS TABLE (Junction Table)
-- ============================================================================
-- Many-to-many relationship between users and groups.

CREATE TABLE group_members (
    group_id INTEGER NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    PRIMARY KEY (group_id, user_id)
);

-- ============================================================================
-- EXPENSES TABLE
-- ============================================================================
-- Stores expenses within groups. Each expense is paid by one user and
-- split among multiple users (tracked in expense_participants table).

CREATE TABLE expenses (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    group_id INTEGER NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
    description TEXT NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    expense_date DATE NOT NULL,
    paid_by_user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
    CHECK (amount >= 0.01),
    CHECK (length(description) >= 1 AND length(description) <= 200)
);

-- ============================================================================
-- EXPENSE PARTICIPANTS TABLE (Junction Table)
-- ============================================================================
-- Tracks which users an expense is split between.
-- The paid_by user MUST be in this table (enforced by application logic).

CREATE TABLE expense_participants (
    expense_id INTEGER NOT NULL REFERENCES expenses(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE RESTRICT,
    PRIMARY KEY (expense_id, user_id)
);

-- ============================================================================
-- NOTES FOR IMPLEMENTATION
-- ============================================================================
--
-- 1. ID GENERATION:
--    - IDs are auto-generated by SQLite using AUTOINCREMENT
--    - Sequential integers: 1, 2, 3, ...
--    - No need to generate IDs in application code
--    - After INSERT, get the ID: cursor.lastrowid or db.session.commit() then object.id
--    - In SQLAlchemy: user = User(...); db.session.add(user); db.session.commit(); user.id is set
--
-- 2. DATE HANDLING:
--    - SQLite stores DATE as ISO 8601 date strings: "2025-01-10"
--    - Expense dates use YYYY-MM-DD format
--    - In Python: use date objects or strings in "YYYY-MM-DD" format
--
-- 3. BOOLEAN VALUES:
--    - Store as INTEGER: 0 = false, 1 = true
--    - In Python: use bool() to convert, or store 0/1 directly
--    - SQLAlchemy's Boolean type handles conversion automatically
--
-- 4. NUMERIC PRECISION:
--    - NUMERIC(10,2) stores up to 99,999,999.99
--    - SQLite will enforce precision
--    - In Python: use Decimal type for calculations, convert to float for JSON
--
-- 5. VALIDATION RULES (enforced in application layer):
--    - paidBy must be in splitBetween (expense_participants)
--    - All users in splitBetween must be group members
--    - paidBy must be a group member
--    - Cannot delete group if expenses exist (check expenses table)
--    - Cannot remove member if they're in expense_participants or paid_by
--
-- 6. TRANSACTIONS:
--    - SQLite supports transactions: BEGIN TRANSACTION; ... COMMIT;
--    - Use for: creating expense + participants, adding member + creating placeholder user
--    - In Flask: use db.session.begin() or @db.transaction decorator
--
-- 7. CASCADING DELETES:
--    - Deleting a group deletes all expenses and group_members (CASCADE)
--    - Deleting an expense deletes all expense_participants (CASCADE)
--    - Deleting a user is RESTRICTED if they're involved in expenses or created groups
--
-- 8. PERFORMANCE:
--    - This simplified schema omits indexes, views, and triggers for simplicity
--    - At small scale (handful of users/groups, few hundred expenses), performance is excellent
--    - Full table scans are fast enough (< 5ms for typical queries)
--    - If needed later, see full_db/ folder for optimized version with indexes
--
-- 9. FLASK SETUP:
--    - Use Flask-SQLAlchemy for ORM (recommended)
--    - Or use sqlite3 directly with connection management
--    - Enable foreign keys: conn.execute("PRAGMA foreign_keys = ON")
--
-- 10. BACKUP:
--     - SQLite database is a single file: cost_sharing.db
--     - Easy to backup: just copy the file
--     - Can use .dump command: sqlite3 cost_sharing.db .dump > backup.sql
